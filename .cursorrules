# Cursor Rules
# This file contains context information that will be automatically included in your conversations with AI assistants.

# IMPORTANT: All guidelines must start with # or they will be ignored as comments

# Project Guidelines:
# This is a Spring Boot project with JPA
# Use Spring Boot best practices
# The project uses Java 21 - use the most advanced features when possible
# The project uses Maven for dependency management
# Include unit tests and integration tests when possible, differentiate them by name
# Use hexagonal architecture guidelines, splitting domain, infrastructure and application layers
# If any questions are not correct, don't hesitate to correct or ask for additional information

# GOOGLE JAVA STYLE GUIDE COMPLIANCE FOR NEW CODE:
# ALWAYS follow Google Java Style Guide for all new code written
# Use 2-space indentation (not 4-space)
# Use 100 character line length limit
# Use camelCase for variable and method names
# Use PascalCase for class names
# Use UPPER_SNAKE_CASE for constants
# Use descriptive names that are clear and meaningful
# Use braces for all control structures (if, else, for, while, do-while)
# Place opening braces on the same line as the declaration
# Place closing braces on their own line
# Use spaces around operators and after commas
# Use blank lines to separate logical sections
# Use single blank line between methods
# Use two blank lines between classes
# Import statements should be ordered: static imports first, then regular imports
# Use wildcard imports sparingly and only for static imports
# Use @Override annotation when overriding methods
# Use @SuppressWarnings only when necessary and document why
# Use final keyword for variables that won't be reassigned
# Use private fields and methods when possible
# Use public methods only when necessary for the API
# Use package-private (default) access when appropriate
# Use meaningful parameter names in method signatures
# If a method declaration is too long, split parameters one per line
# Use var for local variables when the type is obvious from the context
# Use try-with-resources for AutoCloseable resources
# Use Optional for methods that might return null
# Use Stream API when it improves readability
# Use method chaining when it improves readability
# Use builder pattern for complex object construction
# Use immutable objects when possible
# Use defensive copying for mutable parameters
# Use null checks at the beginning of methods
# Use early returns to reduce nesting
# Use meaningful exception messages
# Use specific exception types rather than generic Exception
# Use logging instead of System.out.println
# Use proper JavaDoc for public APIs
# Use @param, @return, and @throws tags in JavaDoc
# Use consistent formatting for arrays and collections
# Use enum for constants that represent a fixed set of values
# Use record for simple data carriers (Java 14+)
# Use sealed classes/interfaces when appropriate (Java 17+)
# Use pattern matching in switch expressions when appropriate (Java 17+)
# Use text blocks for multi-line strings (Java 15+)

# CRITICAL DEVELOPMENT PRACTICES:
# ALWAYS verify dependency compatibility before making claims - check official documentation, GitHub issues, and release notes
# NEVER assume compatibility issues without proper research - use official sources and recent information
# When dealing with version conflicts, check the latest releases and official compatibility matrices
# For Spring Boot compatibility issues, verify against the official Spring Boot compatibility matrix
# For third-party libraries, check their GitHub issues, releases, and official documentation
# If unsure about compatibility, say "I need to research this" rather than making assumptions
# Always provide sources when making compatibility claims
# When suggesting dependency changes, verify the change works before recommending it 

# CODE CHANGE PRACTICES:
# ONLY make changes that directly support the requested feature or fix
# NEVER refactor unrelated code unless explicitly requested
# PRESERVE existing formatting, indentation, and line breaks exactly as they are
# DON'T "clean up" or "improve" code that wasn't part of the request
# FOCUS on minimal, atomic changes that achieve the specific goal
# AVOID changing import ordering, spacing, or formatting unless necessary for the feature
# KEEP commits and changes focused on a single concern
# DON'T introduce "while I was here" improvements or formatting changes
# DO NOT reformat anything not related with the requested feature
# READ the original file first to understand existing formatting and style
# MAKE minimal, surgical changes - only modify exact lines needed for the feature
# USE precise search and replace with extensive context to avoid unintended changes
# PRESERVE all existing formatting, spacing, and line breaks exactly as they are
# DON'T reorder imports, change indentation style, or reformat method signatures
# DON'T "improve" code style - focus only on requested functionality
# TREAT existing code formatting as sacred and only touch what's absolutely necessary 

# ANALYSIS AND VERIFICATION RULES:
# ALWAYS analyze and verify before making conclusions
# NEVER agree with or confirm user suggestions before doing proper analysis
# When asked to check if something is redundant/correct/needed:
#   1. First analyze the code/data in question thoroughly
#   2. Then provide findings and conclusions based on evidence
#   3. Only then agree or disagree with the user
# Avoid premature agreement or confirmation
# Always say "Let me check/analyze/verify..." before making conclusions
# Base all responses on actual analysis, not assumptions

# TEST ANALYSIS RULES:
# When analyzing test failures or logs:
#   1. ALWAYS read the complete test log/output provided by user
#   2. Look for patterns of test execution (which tests run, how many times)
#   3. Identify actual error messages and stack traces
#   4. Check for duplicate test executions or suite runs
#   5. Verify test configuration and Maven profiles
#   6. NEVER assume test behavior without examining evidence
#   7. If user provides test.log, analyze it line by line for patterns
#   8. Look for test suite executions in logs (IntegrationTestSuite, UnitTestSuite)
#   9. Count how many times each test class appears in the log
#   10. Verify Maven profile configurations match actual test execution

# EVIDENCE-BASED RESPONSES:
# ALWAYS base conclusions on provided evidence (logs, code, error messages)
# NEVER make assumptions about what "should" happen
# If user provides specific data/files, analyze them thoroughly first
# Quote specific lines from logs/code when making claims
# Admit when evidence contradicts initial assumptions
# When user points out an error in analysis, acknowledge and re-examine evidence

# VERIFICATION CHECKLIST:
# Before making any claim about test behavior:
# - Have I read the complete test output/log?
# - Have I identified all test executions in the log?
# - Have I checked for duplicate test runs?
# - Have I verified the Maven configuration?
# - Am I basing conclusions on evidence or assumptions?
# - Have I looked for test suite executions?
# - Have I counted how many times each test appears?